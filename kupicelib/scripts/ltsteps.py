#!/usr/bin/env python

# -------------------------------------------------------------------------------
#
#  ███████╗██████╗ ██╗ ██████╗███████╗██╗     ██╗██████╗
#  ██╔════╝██╔══██╗██║██╔════╝██╔════╝██║     ██║██╔══██╗
#  ███████╗██████╔╝██║██║     █████╗  ██║     ██║██████╔╝
#  ╚════██║██╔═══╝ ██║██║     ██╔══╝  ██║     ██║██╔══██╗
#  ███████║██║     ██║╚██████╗███████╗███████╗██║██████╔╝
#  ╚══════╝╚═╝     ╚═╝ ╚═════╝╚══════╝╚══════╝╚═╝╚═════╝
#
# Name:        ltsteps.py
# Purpose:     Process LTSpice log files and align data for spreadsheet tools
#              such as Excel or Calc.
#
# Author:      Nuno Brum (nuno.brum@gmail.com)
#
# Licence:     refer to the LICENSE file
# -------------------------------------------------------------------------------

"""Process LTSpice auxiliary outputs (log/txt/mout) into tabular data.

This script can be invoked as ``ltsteps <path_to_filename>``. When no filename is
provided, it falls back to the most recent supported file in the current directory.

Supported inputs:

* ``.log`` files - harvested during simulations and containing .STEP/.MEAS results.
* ``.txt`` files - exported waveform data that can be reformatted with run IDs.
* ``.mout`` files - generated by executing .MEAS scripts.

Each input is converted into a tab-separated file with a more analysis-friendly
structure.
"""

from __future__ import annotations

import logging
import os
import sys
from collections.abc import Iterable
from pathlib import Path

from kupicelib.log.ltsteps import LTSpiceLogReader, reformat_LTSpice_export

__author__ = "Nuno Canto Brum <me@nunobrum.com>"
__copyright__ = "Copyright 2023, Fribourg Switzerland"

_logger = logging.getLogger("kupicelib.LTSteps")

VALID_EXTENSIONS: tuple[str, ...] = (".txt", ".log", ".mout")
OUTPUT_SUFFIXES: dict[str, str] = {".txt": ".tsv", ".log": ".tlog", ".mout": ".tmout"}


def _is_valid_extension(filename: str) -> bool:
    """Return True when *filename* ends with a supported suffix."""

    return Path(filename).suffix.lower() in VALID_EXTENSIONS


def _newest_candidate(entries: Iterable[str]) -> str | None:
    """Return the newest supported filename among *entries* or ``None`` when absent."""

    newest_file: tuple[float, str] | None = None
    for entry in entries:
        if not _is_valid_extension(entry):
            continue
        try:
            modified_time = os.path.getmtime(entry)
        except OSError:
            # Skip unreadable paths silently - the CLI will still report missing files.
            continue
        if newest_file is None or modified_time > newest_file[0]:
            newest_file = (modified_time, entry)
    return None if newest_file is None else newest_file[1]


def _derive_output_name(filename: str) -> str:
    """Derive the output filename matching the input suffix."""

    suffix = Path(filename).suffix.lower()
    replacement = OUTPUT_SUFFIXES.get(suffix)
    if replacement is None:
        raise ValueError(
            "This tool only supports '.txt', '.log' and '.mout' inputs."
        )
    return str(Path(filename).with_suffix(replacement))


def main() -> None:
    """Entry point for the CLI."""

    filename: str | None
    if len(sys.argv) > 1:
        filename = sys.argv[1]
        print("Using filename:", filename)
    else:
        # TODO: Replace optparse with argparse. Add a --last option to select the
        # most recent file automatically.
        filename = _newest_candidate(os.listdir())

    if filename is None:
        print("File not found")
        print("This tool only supports the following extensions :'.txt','.log','.mout'")
        sys.exit(-1)

    if not _is_valid_extension(filename):
        print(f"Invalid extension in filename '{filename}'")
        print("This tool only supports the following extensions :'.txt','.log','.mout'")
        sys.exit(-1)

    try:
        output_name = _derive_output_name(filename)
    except ValueError as exc:  # pragma: no cover - defensive guard
        print(str(exc))
        sys.exit(-1)

    print(f"Creating File {output_name}")
    suffix = Path(filename).suffix.lower()
    if suffix == ".txt":
        _logger.debug("Processing Data File")
        reformat_LTSpice_export(filename, output_name)
    elif suffix == ".log":
        data = LTSpiceLogReader(filename)
        data.split_complex_values_on_datasets()
        data.export_data(output_name)
    else:  # .mout
        log_file = str(Path(filename).with_suffix(".log"))
        if os.path.exists(log_file):
            steps = LTSpiceLogReader(log_file, read_measures=False)
            data = LTSpiceLogReader(filename, step_set=steps.stepset)
            data.stepset = steps.stepset
        else:
            # Just reformats
            data = LTSpiceLogReader(filename)
        data.split_complex_values_on_datasets()
        data.export_data(output_name)


if __name__ == "__main__":
    _logger.setLevel(logging.INFO)
    main()
